---
title: "ANLY515 Group Project Saurabh v2"
author: "Saurabh Shirish Prabhu"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
rm(list=ls()) 
knitr::opts_chunk$set(echo = TRUE)
dir.create(tempdir())
```

Importing data from Yahoo finance:

```{r}
getwd()
setwd('F:/a_Harrisburg_University_Academics/ANLY 515-51- A-2024Spring - Risk Modeling and Assessment/Final Project/Code')
getwd()
```


This section contains suitable distribution for portfolios.


Select two market sectors from the 11 sectors identified on this
reference o <https://www.bloomberg.com/markets/sectors>

Answer:

[1]Information Technology<br>

1.1 Semiconductors & Semiconductor Equipment: NVIDIA Corporation (NVDA)<br>
1.2 Software & Services: Microsoft Corporation (MSFT)<br>
1.3 Software & Services: Apple Inc. (AAPL)<br>
1.4 Software & Services: Netflix Inc. (NFLX)<br>


[2]Financials<br>

2.1 Insurance: Berkshire Hathaway Inc. (BRK.B)<br>
2.2 Banks: JPMorgan Chase & Co. (JPM)<br>
2.3 Banks: CitiGroup Inc. (C)<br>
2.4 Insurance: BlackRock Inc. (BLK)<br>



[3]Consumer Discretionary:<br>

3.1 Retailing: McDonald's Corporation (MCD)<br>
3.2 Consumer Durables & Apparel: Skechers U.S.A., Inc. (SKX)<br>
3.3 Retailing: Starbucks Corp. (SBUX) <br>
3.4 Consumer Durables & Apparel: Nike Inc. (NKE)



[4]Industrials: <br>

4.1 Capital Goods: Cummins Inc. (CMI)<br>
4.2 Capital Goods:Deere & Company (DE)<br>


References: <br>
[1]<https://stockanalysis.com/stocks/industry/><br>
[2]<https://medium.com/\@sil.soham/importing-and-visualising-stock-market-data-in-r-ac5a22e23cd><br>


Import all necessary libraries

```{r}
library(quantmod)
library(xts)
library(dplyr)
library(corrplot)
```

Students should have a five-year portfolio. The calculations for this homework will be based on the data from the third year of your portfolio.

• Identify the five-year period of your portfolio

a) Identify the period for this homework

• Use only 4 stocks from your portfolio



Part A – Individual Security Returns
1. Calculate Returns

a) Calculate portfolio price returns for the homework period


2. Dividend reinvestment strategy

a) Calculate portfolio total gross returns for the homework period

b) Calculate portfolio logarithmic gross returns for the homework period

c) Are the results the same?


3. Plot a comparison of Total Price returns and Total Gross returns



Part B – Portfolio Returns

Use the same investment period and the same stocks

1. Create an equally-weighted portfolio (rebalance each quarter)

2. Create a value-weighted portfolio (rebalance each quarter)

a. Create weight pie charts for each quarter

3. Plot a comparison between the EW and the VW portfolio



```{r}

start <- as.Date("2014-12-31",format="%Y-%m-%d")
end <- as.Date("2023-12-31",format="%Y-%m-%d")

# Use getSymbols to retrieve the data

# [1]Information Technology
data.NVDA <- getSymbols("NVDA", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.MSFT <- getSymbols("MSFT", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.AAPL <- getSymbols("AAPL", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.NFLX <- getSymbols("NFLX", src = "yahoo", from = start, to = end, auto.assign = FALSE)

# [2]Financials
data.BRK_B <- getSymbols("BRK-B", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.JPM <- getSymbols("JPM", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.C <- getSymbols("C", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.BLK <- getSymbols("BLK", src = "yahoo", from = start, to = end, auto.assign = FALSE)

# [3]Consumer Discretionary:
data.MCD <- getSymbols("MCD", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.SKX <- getSymbols("SKX", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.SBUX <- getSymbols("SBUX", src = "yahoo", from = start, to = end, auto.assign = FALSE)
data.NKE <- getSymbols("NKE", src = "yahoo", from = start, to = end, auto.assign = FALSE)
# Assign the class "xts" and "zoo" explicitly
# class(data.NVDA) <- c("xts", "zoo")
# Print the class of the assigned variable
class(data.NVDA)


```

Plot the data for each security to check for missing data<br>

• Confirm that there is no missing data<br> 
• Check the dimensions to
verify that the data covers 5 years<br>

```{r}
names(data.BRK_B)
names(data.BRK_B) <- paste(c("BRK_B.Open","BRK_B.High","BRK_B.Low","BRK_B.Close","BRK_B.Volume","BRK_B.Adjusted"))
names(data.BRK_B)
```

```{r}

## Information Technology
par(mfrow = c(2, 2))  # Set up a 2x2 grid layout
plot(data.NVDA$NVDA.Adjusted, main="NVDA")
plot(data.MSFT$MSFT.Adjusted, main="MSFT")
plot(data.AAPL$AAPL.Adjusted, main="AAPL")
plot(data.NFLX$NFLX.Adjusted, main="NFLX")


## Financials
par(mfrow = c(2, 2))  # Set up a 2x2 grid layout
plot(data.BRK_B$BRK_B.Adjusted, main="BRK_B")
plot(data.JPM$JPM.Adjusted, main="JPM")
plot(data.C$C.Adjusted, main="C")
plot(data.BLK$BLK.Adjusted, main="BLK")


## Consumer Discretionary
par(mfrow = c(2, 2))  # Set up a 2x2 grid layout
plot(data.MCD$MCD.Adjusted, main="MCD")
plot(data.SKX$SKX.Adjusted, main="SKX")
plot(data.SBUX$SBUX.Adjusted, main="SBUX")
plot(data.NKE$NKE.Adjusted, main="NKE")

```

```{r}
### Sector 1: Information Technology: MSFT and NVDA
Infotech.Adjusted.Prices <- data.NVDA$NVDA.Adjusted
Infotech.Adjusted.Prices <-cbind(Infotech.Adjusted.Prices,data.MSFT$MSFT.Adjusted)
Infotech.Adjusted.Prices <-cbind(Infotech.Adjusted.Prices,data.AAPL$AAPL.Adjusted)
Infotech.Adjusted.Prices <-cbind(Infotech.Adjusted.Prices,data.NFLX$NFLX.Adjusted)
# Infotech.Adjusted.Prices[c(1:3,nrow(Infotech.Adjusted.Prices)),]




##########
### Sector 2: Financials: BRK_B and JPM
Financials.Adjusted.Prices <- data.BRK_B$BRK_B.Adjusted
Financials.Adjusted.Prices <-cbind(Financials.Adjusted.Prices,data.JPM$JPM.Adjusted)
Financials.Adjusted.Prices <-cbind(Financials.Adjusted.Prices,data.C$C.Adjusted)
Financials.Adjusted.Prices <-cbind(Financials.Adjusted.Prices,data.BLK$BLK.Adjusted)
# Financials.Adjusted.Prices[c(1:3,nrow(Financials.Adjusted.Prices)),]



#########
### Sector 3: Consumer Discretionary: MCD and SKX
Consumer.Adjusted.Prices <- data.MCD$MCD.Adjusted
Consumer.Adjusted.Prices <-cbind(Consumer.Adjusted.Prices,data.SKX$SKX.Adjusted)
Consumer.Adjusted.Prices <-cbind(Consumer.Adjusted.Prices,data.SBUX$SBUX.Adjusted)
Consumer.Adjusted.Prices <-cbind(Consumer.Adjusted.Prices,data.NKE$NKE.Adjusted)
# Consumer.Adjusted.Prices[c(1:3,nrow(Consumer.Adjusted.Prices)),]


########
### Entire portfolio
Portfolio.totret.all <- cbind(Infotech.Adjusted.Prices,Financials.Adjusted.Prices,Consumer.Adjusted.Prices)
Portfolio.totret.all[c(1:3,nrow(Portfolio.totret.all)),]

str(Portfolio.totret.all)
summary(Portfolio.totret.all)
```



Variance covariance matrix: 

Part A – Risks
1. Using two securities from your portfolio (from different sectors)
a) Construct a variance-covariance matrix

```{r}

multi <- Portfolio.totret.all

mat.price <- matrix(multi,nrow(multi))
prc2ret <- function(x) Delt(x)


mat.ret <- apply(mat.price,2,function(x) {prc2ret(c(x))})
mat.ret[c(1:2,nrow(mat.ret)),]


mat.ret <- mat.ret[-1,]
colnames(mat.ret) <- c(
                      "NVDA", "MSFT", "AAPL", "NFLX",
                      "BRK_B",  "JPM", "C",  "BLK",
                      "MCD",  "SKX", "SBUX",  "NKE"
                      )
# mat.ret[1:4,]


# Create a vector of weights AMZN: 25% IBM: 75%

WGT.12asset <- rep(1/12, 12)   ###EQUALLY WEIGHTED
WGT.12asset <- matrix(WGT.12asset,1)
# WGT.12asset
# Create a transposed vector of weights (command: t)

tWGT.12asset <- t(WGT.12asset)
tWGT.12asset


## Calculate annualize and annualize variance-covariance matrix
VCOV <- cov(mat.ret)
VCOV.annual <- nrow(mat.ret)*VCOV   ## 252 is nrow of mat.ret 
VCOV.annual

# Check the range of values in the covariance matrix
min_value <- min(VCOV.annual)
max_value <- max(VCOV.annual)


# Convert covariance matrix to correlation matrix
COR.annual <- cov2cor(VCOV.annual)
corrplot(COR.annual, method = "circle")
```
Part B – Suitable distributions for returns 
1. Fit the data using GHD, HYP and NIG 
2. Plot the combined density functions 
3. Create a Q-Q plot 
4. Make a model recommendation using lik.ratio.test 
5. Calculate and plot the VaR (using all models) 
6. Calculate and plot the ES (using all models)

```{r}
library(fBasics)
library(GeneralizedHyperbolic)
library(FRAPO)
library(ghyp)
library(cccp)
library(Rglpk)
library(slam)

```
```{r}
set.seed(10)
ghypsim<-rghyp(1500)
head(ghypsim)


# Generate datasets using hyperbolic, normal and normal inverse Gaussian simulations
hypsim<-rhyp(1500)
normsim<-rnorm(1500)
nigsim<-rnig(1500)

```
Check data

```{r}
summary(ghypsim)
summary(hypsim)
summary(nigsim)
summary(normsim)


par(mfrow=c(2,2))
hist(nigsim, breaks = 50, col = "yellow", xlim = c(-10,10),ylim = c(0,150))
hist(ghypsim, breaks=50, col="red", xlim=c(-10,10), ylim = c(0,150))
hist(hypsim, breaks=50, col="green", xlim=c(-10,10),ylim = c(0,250))
hist(normsim, breaks=50, col="blue", xlim=c(-10,10),ylim = c(0,150))
box()
```

### Portfolio - 2013 total returns ###

```{r}
period.ret <- Portfolio.totret.all[c(1,nrow(Portfolio.totret.all)),]
# period.ret
rets <- lapply(period.ret,Delt)
# rets  
rets <- data.frame(rets)
# rets


rets <- rets[2,]*100
names(rets) <- paste(c(
                      "NVDA", "MSFT", "AAPL", "NFLX",
                      "BRK_B",  "JPM", "C",  "BLK",
                      "MCD",  "SKX", "SBUX",  "NKE"
                      ))
rets

```



Calculate return time series 

```{r}
port.df <- data.frame(Date = index(Portfolio.totret.all), coredata(Portfolio.totret.all))
port.df[c(1:3,nrow(port.df)),]


Port.rets <-port.df
date<-Port.rets$date
str(date)

PortRet.price <- Port.rets[,-1]


attr(PortRet.price, 'time')<-date   ##add time attribute to dataset
str(PortRet.price)


Port.rets.5yrs<-returnseries(PortRet.price)
# summary(PortRet_2013)
# str(PortRet_2013)
# head(PortRet_2013)
attr(Port.rets.5yrs, 'time')<-date
str(Port.rets.5yrs)
head(Port.rets.5yrs)
```

```{r}
datets<-as.character(date)
PortTimeS<-timeSeries(Port.rets.5yrs, charvec = datets)
str(PortTimeS)
head(PortTimeS)
```
### NVDA ###


```{r}

datets <-as.character(datets)
PortTimeS_NVDA<-timeSeries(PortTimeS$NVDA.Adjusted, charvec = datets)

attr(PortTimeS_NVDA, 'time')<-date   ##add time attribute to dataset
str(PortTimeS_NVDA)

head(PortTimeS_NVDA)


ef_NVDA<-density(PortTimeS_NVDA, na.rm=TRUE)
plot(ef_NVDA)

### Fit distributions
ghdfit_NVDA<- fit.ghypuv(PortTimeS_NVDA, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE,silent = TRUE)
hypfit_NVDA<- fit.hypuv(PortTimeS_NVDA, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)
nigfit_NVDA<- fit.NIGuv(PortTimeS_NVDA, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)


ghddens_NVDA <- dghyp(ef_NVDA$x, ghdfit_NVDA)
hypdens_NVDA <- dghyp(ef_NVDA$x, hypfit_NVDA)
nigdens_NVDA <- dghyp(ef_NVDA$x, nigfit_NVDA)
nordens_NVDA <- dnorm(ef_NVDA$x, mean = mean(PortTimeS_NVDA, na.rm=TRUE), sd = sd(c(PortTimeS_NVDA[, 1]), na.rm=TRUE))
col.def <- c("black", "red", "blue", "green", "orange")
plot(ef_NVDA, xlab = "", ylab = expression(f(x)), ylim = c(0, 0.4),lwd=2)
lines(ef_NVDA$x, ghddens_NVDA, col = "red",lwd=2)
lines(ef_NVDA$x, hypdens_NVDA, col = "blue",lwd=2)
lines(ef_NVDA$x, nigdens_NVDA, col = "green",lwd=2)
lines(ef_NVDA$x, nordens_NVDA, col = "orange",lwd=2)

legend("topleft",
       legend = c("empirical", "GHD", "HYP", "NIG", "NORM"),
       col = col.def, lty = 1)



# Q-Q plot NVDA


qqghyp(ghdfit_NVDA, line = TRUE, ghyp.col = "red", plot.legend = FALSE,
       gaussian = FALSE, main = "Q-Q plot", cex = 0.8)
qqghyp(hypfit_NVDA, add = TRUE, ghyp.pch = 2, ghyp.col = "blue",
       gaussian = FALSE, line = FALSE, cex = 0.8)
qqghyp(nigfit_NVDA, add = TRUE, ghyp.pch = 3, ghyp.col = "green",
       gaussian = FALSE, line = FALSE, cex = 0.8)
legend("topleft", legend = c("GHD", "HYP", "NIG"), 
       col = col.def[-c(1,5)], pch = 1:3)
AIC_NVDA <- stepAIC.ghyp(PortTimeS_NVDA, control = list(maxit = 1000), silent = TRUE)
head(AIC_NVDA$fit.table)
AIC_NVDA$best.model

AIC_NVDA$best.model

LRghdnig_NVDA <- lik.ratio.test(ghdfit_NVDA, nigfit_NVDA)
LRghdnig_NVDA    ##if TRUE there is no relationship between the data sets
LRghdhyp_NVDA <- lik.ratio.test(ghdfit_NVDA, hypfit_NVDA)
LRghdhyp_NVDA    ##if FASLE there is a relationship between the data sets


```
```{r}
# Probabilities & VaR calculation (using quantiles)

p <- seq(0.001, 0.05, 0.001)

# VaR calculation (using quantiles)

ghd.VaR_NVDA <- abs(qghyp(p, ghdfit_NVDA))
hyp.VaR_NVDA <- abs(qghyp(p, hypfit_NVDA))
nig.VaR_NVDA <- abs(qghyp(p, nigfit_NVDA))
nor.VaR_NVDA <- abs(qnorm(p, mean = mean(PortTimeS_NVDA, na.rm=TRUE), sd = sd(c(PortTimeS_NVDA[, 1]), na.rm = TRUE))) 
emp.VaR_NVDA <- abs(quantile(x = PortTimeS_NVDA, probs = p, na.rm=TRUE)) 

# Plotting VaR
plot(emp.VaR_NVDA, type = "l", xlab = "", ylab = "VaR", axes = FALSE, main="NVDA \n Value at Risk (VaR) for Different Distributions",
     ylim = range(c(hyp.VaR_NVDA, nig.VaR_NVDA, ghd.VaR_NVDA, nor.VaR_NVDA, emp.VaR_NVDA)))
box()
axis(1, at = seq(along = p), labels = names(emp.VaR_NVDA), tick = FALSE)
axis(2, at = pretty(range(emp.VaR_NVDA, ghd.VaR_NVDA, hyp.VaR_NVDA,
                          nig.VaR_NVDA, nor.VaR_NVDA)))
lines(seq(along = p), ghd.VaR_NVDA, col = "red")
lines(seq(along = p), hyp.VaR_NVDA, col = "blue")
lines(seq(along = p), nig.VaR_NVDA, col = "green")
lines(seq(along = p), nor.VaR_NVDA, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)


# ES calculation

ghd.ES_NVDA <- abs(ESghyp(p, ghdfit_NVDA))
hyp.ES_NVDA <- abs(ESghyp(p, hypfit_NVDA))
nig.ES_NVDA <- abs(ESghyp(p, nigfit_NVDA))
nor.ES_NVDA <- abs(mean(PortTimeS_NVDA, na.rm=TRUE) - sd(c(PortTimeS_NVDA[, 1]), na.rm = TRUE) *
                dnorm(qnorm(1 - p)) / p)
obs.p_NVDA <- ceiling(p * length(PortTimeS_NVDA))
emp.ES_NVDA <- sapply(obs.p_NVDA, function(x) abs(mean(sort(c(PortTimeS_NVDA))[1:x])))



# Plotting ES

plot(emp.ES_NVDA, type = "l", xlab = "", ylab = "ES", axes = FALSE, main = "NVDA \n Expected Shortfall (ES) for Different Distributions",
     ylim = range(c(hyp.ES_NVDA, nig.ES_NVDA, ghd.ES_NVDA, nor.ES_NVDA, emp.ES_NVDA), na.rm = TRUE))
box()
axis(1, at = 1:length(p), labels = names(emp.VaR_NVDA), tick = FALSE)
axis(2, at = pretty(range(emp.ES_NVDA, ghd.ES_NVDA, hyp.ES_NVDA, nig.ES_NVDA, nor.ES_NVDA)))
lines(1:length(p), ghd.ES_NVDA, col = "red")
lines(1:length(p), hyp.ES_NVDA, col = "blue")
lines(1:length(p), nig.ES_NVDA, col = "green")
lines(1:length(p), nor.ES_NVDA, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)
```
Suitable distributions for 
```{r}
# y <- timeSeries(Portfolio.totret.2013.df[,"NVDA.Adjusted"],charvec = as.character(Portfolio.totret.2013.df[,1]))
# yret <- na.omit(diff(log(y))*100)
# head(yret)

y <- timeSeries(PortTimeS$NVDA.Adjusted, charvec = datets)

rd <- c (1 , 5, 10, 20, 40) 
yrets <- na.omit( matrix(unlist(lapply(rd,
                function(x) diff(log(y),lag = x))),
                ncol = 5) )
head(yrets)


## Function for xi / chi coefficients 5
xichi <- function (x){ 
                      param <- coef(x, type = "alpha.delta") 
                      rho <- param[["beta"]]/param[["alpha"]] 
                      zeta <- param[["delta"]]*sqrt(param [["alpha"]]^2-param[["beta"]]^2)
                      xi <- 1/sqrt(1 + zeta) 
                      chi <- xi*rho 
                      result <- c(chi,xi) 
                      names(result) <- c("chi","xi") 
                      return(result) 
                      } 
## HYP F i t t i n g 
hypfits <- apply(yrets,2,fit.hypuv,symmetric = FALSE,  silent = TRUE ) 
# results <- lapply(hypfits[1], xichi)
# points <- do.call(rbind, results)
# print(points)
points <- matrix(unlist(lapply(hypfits,xichi)),ncol=2, byrow = TRUE)
## Shape tri angle 
col.def <- c("black","blue","red","green","orange") 
leg.def <-paste(rd,rep("day retu rn ",5)) 
plot(points,ylim=c(-0.2,1.2),xlim=c( -1.2,1.2), main="NVDA",
col = col.def,pch=16, ylab=expression(xi),
xlab = expression(chi)) 
lines(x = c(0 , -1) , y = c(0 , 1) )
lines(x = c (0 , 1) , y = c (0 , 1) ) 
lines(x = c( -1, 1) , y = c (1 , 1) ) 
legend ( "bottomright",legend = leg.def , col = col.def ,pch = 16) 
text (x = 0.0 , y = 1.05 , label = "Laplace " , srt = 0) 
text (x = -1.0, y = 1.05 , label = " Exponential " , srt = 0) 
text (x = 1.0 , y = 1.05 , label = "Exponential " , srt = 0) 
text (x = 0.0 , y = -0.1 , label = "Normal" , srt = 0) 
text (x = -0.6, y = 0.5 , label = " Hyperbolic , left skewed" , 
        srt = 302) 
text (x = 0.6 , y = 0.5 , label = " Hyperbolic , right skewed" , 
      srt = 57)


```
### MSFT ###


```{r}

datets <-as.character(datets)
PortTimeS_MSFT<-timeSeries(PortTimeS$MSFT.Adjusted, charvec = datets)

attr(PortTimeS_MSFT, 'time')<-date   ##add time attribute to dataset
str(PortTimeS_MSFT)

head(PortTimeS_MSFT)


ef_MSFT<-density(PortTimeS_MSFT, na.rm=TRUE)
plot(ef_MSFT)

```
```{r}
ghdfit_MSFT<- fit.ghypuv(PortTimeS_MSFT, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE,silent = TRUE)
hypfit_MSFT<- fit.hypuv(PortTimeS_MSFT, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)
nigfit_MSFT<- fit.NIGuv(PortTimeS_MSFT, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)


ghddens_MSFT <- dghyp(ef_MSFT$x, ghdfit_MSFT)
hypdens_MSFT <- dghyp(ef_MSFT$x, hypfit_MSFT)
nigdens_MSFT <- dghyp(ef_MSFT$x, nigfit_MSFT)
nordens_MSFT <- dnorm(ef_MSFT$x, mean = mean(PortTimeS_MSFT, na.rm=TRUE), sd = sd(c(PortTimeS_MSFT[, 1]), na.rm=TRUE))
col.def <- c("black", "red", "blue", "green", "orange")
plot(ef_MSFT, xlab = "", ylab = expression(f(x)), ylim = c(0, 0.4),lwd=2)
lines(ef_MSFT$x, ghddens_MSFT, col = "red",lwd=2)
lines(ef_MSFT$x, hypdens_MSFT, col = "blue",lwd=2)
lines(ef_MSFT$x, nigdens_MSFT, col = "green",lwd=2)
lines(ef_MSFT$x, nordens_MSFT, col = "orange",lwd=2)

legend("topleft",
       legend = c("empirical", "GHD", "HYP", "NIG", "NORM"),
       col = col.def, lty = 1)

```

Q-Q plot MSFT

```{r}
qqghyp(ghdfit_MSFT, line = TRUE, ghyp.col = "red", plot.legend = FALSE,
       gaussian = FALSE, main = "Q-Q plot", cex = 0.8)
qqghyp(hypfit_MSFT, add = TRUE, ghyp.pch = 2, ghyp.col = "blue",
       gaussian = FALSE, line = FALSE, cex = 0.8)
qqghyp(nigfit_MSFT, add = TRUE, ghyp.pch = 3, ghyp.col = "green",
       gaussian = FALSE, line = FALSE, cex = 0.8)
legend("topleft", legend = c("GHD", "HYP", "NIG"), 
       col = col.def[-c(1,5)], pch = 1:3)
AIC_MSFT <- stepAIC.ghyp(PortTimeS_MSFT, control = list(maxit = 1000), silent = TRUE)
head(AIC_MSFT$fit.table)
AIC_MSFT$best.model

AIC_MSFT$best.model

LRghdnig_MSFT <- lik.ratio.test(ghdfit_MSFT, nigfit_MSFT)
LRghdnig_MSFT    ##if TRUE there is no relationship between the data sets
LRghdhyp_MSFT <- lik.ratio.test(ghdfit_MSFT, hypfit_MSFT)
LRghdhyp_MSFT    ##if FASLE there is a relationship between the data sets

```

Probabilities & VaR calculation (using quantiles)
```{R}
p <- seq(0.001, 0.05, 0.001)

# VaR calculation (using quantiles)

ghd.VaR_MSFT <- abs(qghyp(p, ghdfit_MSFT))
hyp.VaR_MSFT <- abs(qghyp(p, hypfit_MSFT))
nig.VaR_MSFT <- abs(qghyp(p, nigfit_MSFT))
nor.VaR_MSFT <- abs(qnorm(p, mean = mean(PortTimeS_MSFT, na.rm=TRUE), sd = sd(c(PortTimeS_MSFT[, 1]), na.rm = TRUE))) 
emp.VaR_MSFT <- abs(quantile(x = PortTimeS_MSFT, probs = p, na.rm=TRUE)) 

# Plotting VaR
plot(emp.VaR_MSFT, type = "l", xlab = "", ylab = "VaR", axes = FALSE, main="MSFT \n Value at Risk (VaR) for Different Distributions",
     ylim = range(c(hyp.VaR_MSFT, nig.VaR_MSFT, ghd.VaR_MSFT, nor.VaR_MSFT, emp.VaR_MSFT)))
box()
axis(1, at = seq(along = p), labels = names(emp.VaR_MSFT), tick = FALSE)
axis(2, at = pretty(range(emp.VaR_MSFT, ghd.VaR_MSFT, hyp.VaR_MSFT,
                          nig.VaR_MSFT, nor.VaR_MSFT)))
lines(seq(along = p), ghd.VaR_MSFT, col = "red")
lines(seq(along = p), hyp.VaR_MSFT, col = "blue")
lines(seq(along = p), nig.VaR_MSFT, col = "green")
lines(seq(along = p), nor.VaR_MSFT, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)


# ES calculation

ghd.ES_MSFT <- abs(ESghyp(p, ghdfit_MSFT))
hyp.ES_MSFT <- abs(ESghyp(p, hypfit_MSFT))
nig.ES_MSFT <- abs(ESghyp(p, nigfit_MSFT))
nor.ES_MSFT <- abs(mean(PortTimeS_MSFT, na.rm=TRUE) - sd(c(PortTimeS_MSFT[, 1]), na.rm = TRUE) *
                dnorm(qnorm(1 - p)) / p)
obs.p_MSFT <- ceiling(p * length(PortTimeS_MSFT))
emp.ES_MSFT <- sapply(obs.p_MSFT, function(x) abs(mean(sort(c(PortTimeS_MSFT))[1:x])))



# Plotting ES

plot(emp.ES_MSFT, type = "l", xlab = "", ylab = "ES", axes = FALSE, main = "MSFT \n Expected Shortfall (ES) for Different Distributions",
     ylim = range(c(hyp.ES_MSFT, nig.ES_MSFT, ghd.ES_MSFT, nor.ES_MSFT, emp.ES_MSFT), na.rm = TRUE))
box()
axis(1, at = 1:length(p), labels = names(emp.VaR_MSFT), tick = FALSE)
axis(2, at = pretty(range(emp.ES_MSFT, ghd.ES_MSFT, hyp.ES_MSFT, nig.ES_MSFT, nor.ES_MSFT)))
lines(1:length(p), ghd.ES_MSFT, col = "red")
lines(1:length(p), hyp.ES_MSFT, col = "blue")
lines(1:length(p), nig.ES_MSFT, col = "green")
lines(1:length(p), nor.ES_MSFT, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)
```

### AAPL ###


```{r}

datets <-as.character(datets)
PortTimeS_AAPL<-timeSeries(PortTimeS$AAPL.Adjusted, charvec = datets)

attr(PortTimeS_AAPL, 'time')<-date   ##add time attribute to dataset
str(PortTimeS_AAPL)

head(PortTimeS_AAPL)


ef_AAPL<-density(PortTimeS_AAPL, na.rm=TRUE)
plot(ef_AAPL)


ghdfit_AAPL<- fit.ghypuv(PortTimeS_AAPL, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE,silent = TRUE)
hypfit_AAPL<- fit.hypuv(PortTimeS_AAPL, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)
nigfit_AAPL<- fit.NIGuv(PortTimeS_AAPL, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)


ghddens_AAPL <- dghyp(ef_AAPL$x, ghdfit_AAPL)
hypdens_AAPL <- dghyp(ef_AAPL$x, hypfit_AAPL)
nigdens_AAPL <- dghyp(ef_AAPL$x, nigfit_AAPL)
nordens_AAPL <- dnorm(ef_AAPL$x, mean = mean(PortTimeS_AAPL, na.rm=TRUE), sd = sd(c(PortTimeS_AAPL[, 1]), na.rm=TRUE))
col.def <- c("black", "red", "blue", "green", "orange")
plot(ef_AAPL, xlab = "", ylab = expression(f(x)), ylim = c(0, 0.4),lwd=2)
lines(ef_AAPL$x, ghddens_AAPL, col = "red",lwd=3)
lines(ef_AAPL$x, hypdens_AAPL, col = "blue",lwd=2)
lines(ef_AAPL$x, nigdens_AAPL, col = "green",lwd=2)
lines(ef_AAPL$x, nordens_AAPL, col = "orange",lwd=2)

legend("topleft",
       legend = c("empirical", "GHD", "HYP", "NIG", "NORM"),
       col = col.def, lty = 1)


# Q-Q plot AAPL


qqghyp(ghdfit_AAPL, line = TRUE, ghyp.col = "red", plot.legend = FALSE,
       gaussian = FALSE, main = "Q-Q plot", cex = 0.9)
qqghyp(hypfit_AAPL, add = TRUE, ghyp.pch = 2, ghyp.col = "blue",
       gaussian = FALSE, line = FALSE, cex = 0.8)
qqghyp(nigfit_AAPL, add = TRUE, ghyp.pch = 3, ghyp.col = "green",
       gaussian = FALSE, line = FALSE, cex = 0.8)
legend("topleft", legend = c("GHD", "HYP", "NIG"), 
       col = col.def[-c(1,5)], pch = 1:3)
AIC_AAPL <- stepAIC.ghyp(PortTimeS_AAPL, control = list(maxit = 1000), silent = TRUE)
head(AIC_AAPL$fit.table)
AIC_AAPL$best.model

AIC_AAPL$best.model

LRghdnig_AAPL <- lik.ratio.test(ghdfit_AAPL, nigfit_AAPL)
LRghdnig_AAPL    ##if TRUE there is no relationship between the data sets
LRghdhyp_AAPL <- lik.ratio.test(ghdfit_AAPL, hypfit_AAPL)
LRghdhyp_AAPL    ##if FASLE there is a relationship between the data sets

```

Probabilities & VaR calculation (using quantiles)
```{r}
p <- seq(0.001, 0.05, 0.001)

# VaR calculation (using quantiles)

ghd.VaR_AAPL <- abs(qghyp(p, ghdfit_AAPL))
hyp.VaR_AAPL <- abs(qghyp(p, hypfit_AAPL))
nig.VaR_AAPL <- abs(qghyp(p, nigfit_AAPL))
nor.VaR_AAPL <- abs(qnorm(p, mean = mean(PortTimeS_AAPL, na.rm=TRUE), sd = sd(c(PortTimeS_AAPL[, 1]), na.rm = TRUE))) 
emp.VaR_AAPL <- abs(quantile(x = PortTimeS_AAPL, probs = p, na.rm=TRUE)) 

# Plotting VaR
plot(emp.VaR_AAPL, type = "l", xlab = "", ylab = "VaR", axes = FALSE, main="AAPL \n Value at Risk (VaR) for Different Distributions",
     ylim = range(c(hyp.VaR_AAPL, nig.VaR_AAPL, ghd.VaR_AAPL, nor.VaR_AAPL, emp.VaR_AAPL)))
box()
axis(1, at = seq(along = p), labels = names(emp.VaR_AAPL), tick = FALSE)
axis(2, at = pretty(range(emp.VaR_AAPL, ghd.VaR_AAPL, hyp.VaR_AAPL,
                          nig.VaR_AAPL, nor.VaR_AAPL)))
lines(seq(along = p), ghd.VaR_AAPL, col = "red")
lines(seq(along = p), hyp.VaR_AAPL, col = "blue")
lines(seq(along = p), nig.VaR_AAPL, col = "green")
lines(seq(along = p), nor.VaR_AAPL, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)


# ES calculation

ghd.ES_AAPL <- abs(ESghyp(p, ghdfit_AAPL))
hyp.ES_AAPL <- abs(ESghyp(p, hypfit_AAPL))
nig.ES_AAPL <- abs(ESghyp(p, nigfit_AAPL))
nor.ES_AAPL <- abs(mean(PortTimeS_AAPL, na.rm=TRUE) - sd(c(PortTimeS_AAPL[, 1]), na.rm = TRUE) *
                dnorm(qnorm(1 - p)) / p)
obs.p_AAPL <- ceiling(p * length(PortTimeS_AAPL))
emp.ES_AAPL <- sapply(obs.p_AAPL, function(x) abs(mean(sort(c(PortTimeS_AAPL))[1:x])))



# Plotting ES

plot(emp.ES_AAPL, type = "l", xlab = "", ylab = "ES", axes = FALSE, main = "AAPL \n Expected Shortfall (ES) for Different Distributions",
     ylim = range(c(hyp.ES_AAPL, nig.ES_AAPL, ghd.ES_AAPL, nor.ES_AAPL, emp.ES_AAPL), na.rm = TRUE))
box()
axis(1, at = 1:length(p), labels = names(emp.VaR_AAPL), tick = FALSE)
axis(2, at = pretty(range(emp.ES_AAPL, ghd.ES_AAPL, hyp.ES_AAPL, nig.ES_AAPL, nor.ES_AAPL)))
lines(1:length(p), ghd.ES_AAPL, col = "red")
lines(1:length(p), hyp.ES_AAPL, col = "blue")
lines(1:length(p), nig.ES_AAPL, col = "green")
lines(1:length(p), nor.ES_AAPL, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)
```
### NFLX ###


```{r}

datets <-as.character(datets)
PortTimeS_NFLX<-timeSeries(PortTimeS$NFLX.Adjusted, charvec = datets)

attr(PortTimeS_NFLX, 'time')<-date   ##add time attribute to dataset
str(PortTimeS_NFLX)

head(PortTimeS_NFLX)


ef_NFLX<-density(PortTimeS_NFLX, na.rm=TRUE)
plot(ef_NFLX)


ghdfit_NFLX<- fit.ghypuv(PortTimeS_NFLX, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE,silent = TRUE)
hypfit_NFLX<- fit.hypuv(PortTimeS_NFLX, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)
nigfit_NFLX<- fit.NIGuv(PortTimeS_NFLX, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)


ghddens_NFLX <- dghyp(ef_NFLX$x, ghdfit_NFLX)
hypdens_NFLX <- dghyp(ef_NFLX$x, hypfit_NFLX)
nigdens_NFLX <- dghyp(ef_NFLX$x, nigfit_NFLX)
nordens_NFLX <- dnorm(ef_NFLX$x, mean = mean(PortTimeS_NFLX, na.rm=TRUE), sd = sd(c(PortTimeS_NFLX[, 1]), na.rm=TRUE))
col.def <- c("black", "red", "blue", "green", "orange")
plot(ef_NFLX, xlab = "", ylab = expression(f(x)), ylim = c(0, 0.4),lwd=2)
lines(ef_NFLX$x, ghddens_NFLX, col = "red",lwd=3)
lines(ef_NFLX$x, hypdens_NFLX, col = "blue",lwd=2)
lines(ef_NFLX$x, nigdens_NFLX, col = "green",lwd=2)
lines(ef_NFLX$x, nordens_NFLX, col = "orange",lwd=2)

legend("topleft",
       legend = c("empirical", "GHD", "HYP", "NIG", "NORM"),
       col = col.def, lty = 1)


# Q-Q plot NFLX


qqghyp(ghdfit_NFLX, line = TRUE, ghyp.col = "red", plot.legend = FALSE,
       gaussian = FALSE, main = "Q-Q plot", cex = 0.9)
qqghyp(hypfit_NFLX, add = TRUE, ghyp.pch = 2, ghyp.col = "blue",
       gaussian = FALSE, line = FALSE, cex = 0.8)
qqghyp(nigfit_NFLX, add = TRUE, ghyp.pch = 3, ghyp.col = "green",
       gaussian = FALSE, line = FALSE, cex = 0.8)
legend("topleft", legend = c("GHD", "HYP", "NIG"), 
       col = col.def[-c(1,5)], pch = 1:3)
AIC_NFLX <- stepAIC.ghyp(PortTimeS_NFLX, control = list(maxit = 1000), silent = TRUE)
head(AIC_NFLX$fit.table)
AIC_NFLX$best.model

AIC_NFLX$best.model

LRghdnig_NFLX <- lik.ratio.test(ghdfit_NFLX, nigfit_NFLX)
LRghdnig_NFLX    ##if TRUE there is no relationship between the data sets
LRghdhyp_NFLX <- lik.ratio.test(ghdfit_NFLX, hypfit_NFLX)
LRghdhyp_NFLX    ##if FASLE there is a relationship between the data sets

```

Probabilities & VaR calculation (using quantiles)
```{r}
p <- seq(0.001, 0.05, 0.001)

# VaR calculation (using quantiles)

ghd.VaR_NFLX <- abs(qghyp(p, ghdfit_NFLX))
hyp.VaR_NFLX <- abs(qghyp(p, hypfit_NFLX))
nig.VaR_NFLX <- abs(qghyp(p, nigfit_NFLX))
nor.VaR_NFLX <- abs(qnorm(p, mean = mean(PortTimeS_NFLX, na.rm=TRUE), sd = sd(c(PortTimeS_NFLX[, 1]), na.rm = TRUE))) 
emp.VaR_NFLX <- abs(quantile(x = PortTimeS_NFLX, probs = p, na.rm=TRUE)) 

# Plotting VaR
plot(emp.VaR_NFLX, type = "l", xlab = "", ylab = "VaR", axes = FALSE, main="NFLX \n Value at Risk (VaR) for Different Distributions",
     ylim = range(c(hyp.VaR_NFLX, nig.VaR_NFLX, ghd.VaR_NFLX, nor.VaR_NFLX, emp.VaR_NFLX)))
box()
axis(1, at = seq(along = p), labels = names(emp.VaR_NFLX), tick = FALSE)
axis(2, at = pretty(range(emp.VaR_NFLX, ghd.VaR_NFLX, hyp.VaR_NFLX,
                          nig.VaR_NFLX, nor.VaR_NFLX)))
lines(seq(along = p), ghd.VaR_NFLX, col = "red")
lines(seq(along = p), hyp.VaR_NFLX, col = "blue")
lines(seq(along = p), nig.VaR_NFLX, col = "green")
lines(seq(along = p), nor.VaR_NFLX, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)


# ES calculation

ghd.ES_NFLX <- abs(ESghyp(p, ghdfit_NFLX))
hyp.ES_NFLX <- abs(ESghyp(p, hypfit_NFLX))
nig.ES_NFLX <- abs(ESghyp(p, nigfit_NFLX))
nor.ES_NFLX <- abs(mean(PortTimeS_NFLX, na.rm=TRUE) - sd(c(PortTimeS_NFLX[, 1]), na.rm = TRUE) *
                dnorm(qnorm(1 - p)) / p)
obs.p_NFLX <- ceiling(p * length(PortTimeS_NFLX))
emp.ES_NFLX <- sapply(obs.p_NFLX, function(x) abs(mean(sort(c(PortTimeS_NFLX))[1:x])))



# Plotting ES

plot(emp.ES_NFLX, type = "l", xlab = "", ylab = "ES", axes = FALSE, main = "NFLX \n Expected Shortfall (ES) for Different Distributions",
     ylim = range(c(hyp.ES_NFLX, nig.ES_NFLX, ghd.ES_NFLX, nor.ES_NFLX, emp.ES_NFLX), na.rm = TRUE))
box()
axis(1, at = 1:length(p), labels = names(emp.VaR_NFLX), tick = FALSE)
axis(2, at = pretty(range(emp.ES_NFLX, ghd.ES_NFLX, hyp.ES_NFLX, nig.ES_NFLX, nor.ES_NFLX)))
lines(1:length(p), ghd.ES_NFLX, col = "red")
lines(1:length(p), hyp.ES_NFLX, col = "blue")
lines(1:length(p), nig.ES_NFLX, col = "green")
lines(1:length(p), nor.ES_NFLX, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)
```


### BRK_B ###


```{r}

datets <-as.character(datets)
PortTimeS_BRK_B<-timeSeries(PortTimeS$BRK_B.Adjusted, charvec = datets)

attr(PortTimeS_BRK_B, 'time')<-date   ##add time attribute to dataset
str(PortTimeS_BRK_B)

head(PortTimeS_BRK_B)


ef_BRK_B<-density(PortTimeS_BRK_B, na.rm=TRUE)
plot(ef_BRK_B)


ghdfit_BRK_B<- fit.ghypuv(PortTimeS_BRK_B, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE,silent = TRUE)
hypfit_BRK_B<- fit.hypuv(PortTimeS_BRK_B, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)
nigfit_BRK_B<- fit.NIGuv(PortTimeS_BRK_B, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)


ghddens_BRK_B <- dghyp(ef_BRK_B$x, ghdfit_BRK_B)
hypdens_BRK_B <- dghyp(ef_BRK_B$x, hypfit_BRK_B)
nigdens_BRK_B <- dghyp(ef_BRK_B$x, nigfit_BRK_B)
nordens_BRK_B <- dnorm(ef_BRK_B$x, mean = mean(PortTimeS_BRK_B, na.rm=TRUE), sd = sd(c(PortTimeS_BRK_B[, 1]), na.rm=TRUE))
col.def <- c("black", "red", "blue", "green", "orange")
plot(ef_BRK_B, xlab = "", ylab = expression(f(x)), ylim = c(0, 0.6),lwd=2)
lines(ef_BRK_B$x, ghddens_BRK_B, col = "red",lwd=3)
lines(ef_BRK_B$x, hypdens_BRK_B, col = "blue",lwd=2)
lines(ef_BRK_B$x, nigdens_BRK_B, col = "green",lwd=2)
lines(ef_BRK_B$x, nordens_BRK_B, col = "orange",lwd=2)

legend("topleft",
       legend = c("empirical", "GHD", "HYP", "NIG", "NORM"),
       col = col.def, lty = 1)


# Q-Q plot BRK_B


qqghyp(ghdfit_BRK_B, line = TRUE, ghyp.col = "red", plot.legend = FALSE,
       gaussian = FALSE, main = "Q-Q plot", cex = 0.9)
qqghyp(hypfit_BRK_B, add = TRUE, ghyp.pch = 2, ghyp.col = "blue",
       gaussian = FALSE, line = FALSE, cex = 0.8)
qqghyp(nigfit_BRK_B, add = TRUE, ghyp.pch = 3, ghyp.col = "green",
       gaussian = FALSE, line = FALSE, cex = 0.8)
legend("topleft", legend = c("GHD", "HYP", "NIG"), 
       col = col.def[-c(1,5)], pch = 1:3)
AIC_BRK_B <- stepAIC.ghyp(PortTimeS_BRK_B, control = list(maxit = 1000), silent = TRUE)
head(AIC_BRK_B$fit.table)
AIC_BRK_B$best.model

AIC_BRK_B$best.model

LRghdnig_BRK_B <- lik.ratio.test(ghdfit_BRK_B, nigfit_BRK_B)
LRghdnig_BRK_B    ##if TRUE there is no relationship between the data sets
LRghdhyp_BRK_B <- lik.ratio.test(ghdfit_BRK_B, hypfit_BRK_B)
LRghdhyp_BRK_B    ##if FASLE there is a relationship between the data sets

```

Probabilities & VaR calculation (using quantiles)
```{r}
p <- seq(0.001, 0.05, 0.001)

# VaR calculation (using quantiles)

ghd.VaR_BRK_B <- abs(qghyp(p, ghdfit_BRK_B))
hyp.VaR_BRK_B <- abs(qghyp(p, hypfit_BRK_B))
nig.VaR_BRK_B <- abs(qghyp(p, nigfit_BRK_B))
nor.VaR_BRK_B <- abs(qnorm(p, mean = mean(PortTimeS_BRK_B, na.rm=TRUE), sd = sd(c(PortTimeS_BRK_B[, 1]), na.rm = TRUE))) 
emp.VaR_BRK_B <- abs(quantile(x = PortTimeS_BRK_B, probs = p, na.rm=TRUE)) 

# Plotting VaR
plot(emp.VaR_BRK_B, type = "l", xlab = "", ylab = "VaR", axes = FALSE, main="BRK_B \n Value at Risk (VaR) for Different Distributions",
     ylim = range(c(hyp.VaR_BRK_B, nig.VaR_BRK_B, ghd.VaR_BRK_B, nor.VaR_BRK_B, emp.VaR_BRK_B)))
box()
axis(1, at = seq(along = p), labels = names(emp.VaR_BRK_B), tick = FALSE)
axis(2, at = pretty(range(emp.VaR_BRK_B, ghd.VaR_BRK_B, hyp.VaR_BRK_B,
                          nig.VaR_BRK_B, nor.VaR_BRK_B)))
lines(seq(along = p), ghd.VaR_BRK_B, col = "red")
lines(seq(along = p), hyp.VaR_BRK_B, col = "blue")
lines(seq(along = p), nig.VaR_BRK_B, col = "green")
lines(seq(along = p), nor.VaR_BRK_B, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)


# ES calculation

ghd.ES_BRK_B <- abs(ESghyp(p, ghdfit_BRK_B))
hyp.ES_BRK_B <- abs(ESghyp(p, hypfit_BRK_B))
nig.ES_BRK_B <- abs(ESghyp(p, nigfit_BRK_B))
nor.ES_BRK_B <- abs(mean(PortTimeS_BRK_B, na.rm=TRUE) - sd(c(PortTimeS_BRK_B[, 1]), na.rm = TRUE) *
                dnorm(qnorm(1 - p)) / p)
obs.p_BRK_B <- ceiling(p * length(PortTimeS_BRK_B))
emp.ES_BRK_B <- sapply(obs.p_BRK_B, function(x) abs(mean(sort(c(PortTimeS_BRK_B))[1:x])))



# Plotting ES

plot(emp.ES_BRK_B, type = "l", xlab = "", ylab = "ES", axes = FALSE, main = "BRK_B \n Expected Shortfall (ES) for Different Distributions",
     ylim = range(c(hyp.ES_BRK_B, nig.ES_BRK_B, ghd.ES_BRK_B, nor.ES_BRK_B, emp.ES_BRK_B), na.rm = TRUE))
box()
axis(1, at = 1:length(p), labels = names(emp.VaR_BRK_B), tick = FALSE)
axis(2, at = pretty(range(emp.ES_BRK_B, ghd.ES_BRK_B, hyp.ES_BRK_B, nig.ES_BRK_B, nor.ES_BRK_B)))
lines(1:length(p), ghd.ES_BRK_B, col = "red")
lines(1:length(p), hyp.ES_BRK_B, col = "blue")
lines(1:length(p), nig.ES_BRK_B, col = "green")
lines(1:length(p), nor.ES_BRK_B, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)
```

Suitable distributions for 
```{r}
# y <- timeSeries(Portfolio.totret.2013.df[,"NVDA.Adjusted"],charvec = as.character(Portfolio.totret.2013.df[,1]))
# yret <- na.omit(diff(log(y))*100)
# head(yret)

y <- timeSeries(PortTimeS$BRK_B.Adjusted, charvec = datets)

rd <- c (1 , 5, 10, 20, 40) 
yrets <- na.omit( matrix(unlist(lapply(rd,
                function(x) diff(log(y),lag = x))),
                ncol = 5) )
head(yrets)


## Function for xi / chi coefficients 5
xichi <- function (x){ 
                      param <- coef(x, type = "alpha.delta") 
                      rho <- param[["beta"]]/param[["alpha"]] 
                      zeta <- param[["delta"]]*sqrt(param [["alpha"]]^2-param[["beta"]]^2)
                      xi <- 1/sqrt(1 + zeta) 
                      chi <- xi*rho 
                      result <- c(chi,xi) 
                      names(result) <- c("chi","xi") 
                      return(result) 
                      } 
## HYP F i t t i n g 
hypfits <- apply(yrets,2,fit.hypuv,symmetric = FALSE,  silent = TRUE ) 
# results <- lapply(hypfits[1], xichi)
# points <- do.call(rbind, results)
# print(points)
points <- matrix(unlist(lapply(hypfits,xichi)),ncol=2, byrow = TRUE)
## Shape tri angle 
col.def <- c("black","blue","red","green","orange") 
leg.def <-paste(rd,rep("day retu rn ",5)) 
plot(points,ylim=c(-0.2,1.2),xlim=c( -1.2,1.2), main="BRK_B",
col = col.def,pch=16, ylab=expression(xi),
xlab = expression(chi)) 
lines(x = c(0 , -1) , y = c(0 , 1) )
lines(x = c (0 , 1) , y = c (0 , 1) ) 
lines(x = c( -1, 1) , y = c (1 , 1) ) 
legend ( "bottomright",legend = leg.def , col = col.def ,pch = 16) 
text (x = 0.0 , y = 1.05 , label = "Laplace " , srt = 0) 
text (x = -1.0, y = 1.05 , label = " Exponential " , srt = 0) 
text (x = 1.0 , y = 1.05 , label = "Exponential " , srt = 0) 
text (x = 0.0 , y = -0.1 , label = "Normal" , srt = 0) 
text (x = -0.6, y = 0.5 , label = " Hyperbolic , left skewed" , 
        srt = 302) 
text (x = 0.6 , y = 0.5 , label = " Hyperbolic , right skewed" , 
      srt = 57)


```



### JPM ###


```{r}

datets <-as.character(datets)
PortTimeS_JPM<-timeSeries(PortTimeS$JPM.Adjusted, charvec = datets)

attr(PortTimeS_JPM, 'time')<-date   ##add time attribute to dataset
str(PortTimeS_JPM)

head(PortTimeS_JPM)


ef_JPM<-density(PortTimeS_JPM, na.rm=TRUE)
plot(ef_JPM)


ghdfit_JPM<- fit.ghypuv(PortTimeS_JPM, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE,silent = TRUE)
hypfit_JPM<- fit.hypuv(PortTimeS_JPM, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)
nigfit_JPM<- fit.NIGuv(PortTimeS_JPM, symmetric = FALSE, control = list(maxit = 500), na.rm = TRUE, silent = TRUE)


ghddens_JPM <- dghyp(ef_JPM$x, ghdfit_JPM)
hypdens_JPM <- dghyp(ef_JPM$x, hypfit_JPM)
nigdens_JPM <- dghyp(ef_JPM$x, nigfit_JPM)
nordens_JPM <- dnorm(ef_JPM$x, mean = mean(PortTimeS_JPM, na.rm=TRUE), sd = sd(c(PortTimeS_JPM[, 1]), na.rm=TRUE))
col.def <- c("black", "red", "blue", "green", "orange")
plot(ef_JPM, xlab = "", ylab = expression(f(x)), ylim = c(0, 0.6),lwd=2)
lines(ef_JPM$x, ghddens_JPM, col = "red",lwd=3)
lines(ef_JPM$x, hypdens_JPM, col = "blue",lwd=2)
lines(ef_JPM$x, nigdens_JPM, col = "green",lwd=2)
lines(ef_JPM$x, nordens_JPM, col = "orange",lwd=2)

legend("topleft",
       legend = c("empirical", "GHD", "HYP", "NIG", "NORM"),
       col = col.def, lty = 1)


# Q-Q plot JPM


qqghyp(ghdfit_JPM, line = TRUE, ghyp.col = "red", plot.legend = FALSE,
       gaussian = FALSE, main = "Q-Q plot", cex = 0.9)
qqghyp(hypfit_JPM, add = TRUE, ghyp.pch = 2, ghyp.col = "blue",
       gaussian = FALSE, line = FALSE, cex = 0.8)
qqghyp(nigfit_JPM, add = TRUE, ghyp.pch = 3, ghyp.col = "green",
       gaussian = FALSE, line = FALSE, cex = 0.8)
legend("topleft", legend = c("GHD", "HYP", "NIG"), 
       col = col.def[-c(1,5)], pch = 1:3)
AIC_JPM <- stepAIC.ghyp(PortTimeS_JPM, control = list(maxit = 1000), silent = TRUE)
head(AIC_JPM$fit.table)
AIC_JPM$best.model

AIC_JPM$best.model

LRghdnig_JPM <- lik.ratio.test(ghdfit_JPM, nigfit_JPM)
LRghdnig_JPM    ##if TRUE there is no relationship between the data sets
LRghdhyp_JPM <- lik.ratio.test(ghdfit_JPM, hypfit_JPM)
LRghdhyp_JPM    ##if FASLE there is a relationship between the data sets

```

Probabilities & VaR calculation (using quantiles)
```{r}
p <- seq(0.001, 0.05, 0.001)

# VaR calculation (using quantiles)

ghd.VaR_JPM <- abs(qghyp(p, ghdfit_JPM))
hyp.VaR_JPM <- abs(qghyp(p, hypfit_JPM))
nig.VaR_JPM <- abs(qghyp(p, nigfit_JPM))
nor.VaR_JPM <- abs(qnorm(p, mean = mean(PortTimeS_JPM, na.rm=TRUE), sd = sd(c(PortTimeS_JPM[, 1]), na.rm = TRUE))) 
emp.VaR_JPM <- abs(quantile(x = PortTimeS_JPM, probs = p, na.rm=TRUE)) 

# Plotting VaR
plot(emp.VaR_JPM, type = "l", xlab = "", ylab = "VaR", axes = FALSE, main="JPM \n Value at Risk (VaR) for Different Distributions",
     ylim = range(c(hyp.VaR_JPM, nig.VaR_JPM, ghd.VaR_JPM, nor.VaR_JPM, emp.VaR_JPM)))
box()
axis(1, at = seq(along = p), labels = names(emp.VaR_JPM), tick = FALSE)
axis(2, at = pretty(range(emp.VaR_JPM, ghd.VaR_JPM, hyp.VaR_JPM,
                          nig.VaR_JPM, nor.VaR_JPM)))
lines(seq(along = p), ghd.VaR_JPM, col = "red")
lines(seq(along = p), hyp.VaR_JPM, col = "blue")
lines(seq(along = p), nig.VaR_JPM, col = "green")
lines(seq(along = p), nor.VaR_JPM, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)


# ES calculation

ghd.ES_JPM <- abs(ESghyp(p, ghdfit_JPM))
hyp.ES_JPM <- abs(ESghyp(p, hypfit_JPM))
nig.ES_JPM <- abs(ESghyp(p, nigfit_JPM))
nor.ES_JPM <- abs(mean(PortTimeS_JPM, na.rm=TRUE) - sd(c(PortTimeS_JPM[, 1]), na.rm = TRUE) *
                dnorm(qnorm(1 - p)) / p)
obs.p_JPM <- ceiling(p * length(PortTimeS_JPM))
emp.ES_JPM <- sapply(obs.p_JPM, function(x) abs(mean(sort(c(PortTimeS_JPM))[1:x])))



# Plotting ES

plot(emp.ES_JPM, type = "l", xlab = "", ylab = "ES", axes = FALSE, main = "JPM \n Expected Shortfall (ES) for Different Distributions",
     ylim = range(c(hyp.ES_JPM, nig.ES_JPM, ghd.ES_JPM, nor.ES_JPM, emp.ES_JPM), na.rm = TRUE))
box()
axis(1, at = 1:length(p), labels = names(emp.VaR_JPM), tick = FALSE)
axis(2, at = pretty(range(emp.ES_JPM, ghd.ES_JPM, hyp.ES_JPM, nig.ES_JPM, nor.ES_JPM)))
lines(1:length(p), ghd.ES_JPM, col = "red")
lines(1:length(p), hyp.ES_JPM, col = "blue")
lines(1:length(p), nig.ES_JPM, col = "green")
lines(1:length(p), nor.ES_JPM, col = "orange")
legend("topright",
       legend = c("Empirical", "GHD Generalized Hyperbolic", "HYP Hyperbolic", "NIG Normal Inverse Gaussian", "Normal"),
       col = col.def, lty = 1)
```

Suitable distributions for 
```{r}
# y <- timeSeries(Portfolio.totret.2013.df[,"NVDA.Adjusted"],charvec = as.character(Portfolio.totret.2013.df[,1]))
# yret <- na.omit(diff(log(y))*100)
# head(yret)

y <- timeSeries(PortTimeS$JPM.Adjusted, charvec = datets)

rd <- c (1 , 5, 10, 20, 40) 
yrets <- na.omit( matrix(unlist(lapply(rd,
                function(x) diff(log(y),lag = x))),
                ncol = 5) )
head(yrets)


## Function for xi / chi coefficients 5
xichi <- function (x){ 
                      param <- coef(x, type = "alpha.delta") 
                      rho <- param[["beta"]]/param[["alpha"]] 
                      zeta <- param[["delta"]]*sqrt(param [["alpha"]]^2-param[["beta"]]^2)
                      xi <- 1/sqrt(1 + zeta) 
                      chi <- xi*rho 
                      result <- c(chi,xi) 
                      names(result) <- c("chi","xi") 
                      return(result) 
                      } 
## HYP F i t t i n g 
hypfits <- apply(yrets,2,fit.hypuv,symmetric = FALSE,  silent = TRUE ) 
# results <- lapply(hypfits[1], xichi)
# points <- do.call(rbind, results)
# print(points)
points <- matrix(unlist(lapply(hypfits,xichi)),ncol=2, byrow = TRUE)
## Shape tri angle 
col.def <- c("black","blue","red","green","orange") 
leg.def <-paste(rd,rep("day retu rn ",5)) 
plot(points,ylim=c(-0.2,1.2),xlim=c( -1.2,1.2), main="JPM",
col = col.def,pch=16, ylab=expression(xi),
xlab = expression(chi)) 
lines(x = c(0 , -1) , y = c(0 , 1) )
lines(x = c (0 , 1) , y = c (0 , 1) ) 
lines(x = c( -1, 1) , y = c (1 , 1) ) 
legend ( "bottomright",legend = leg.def , col = col.def ,pch = 16) 
text (x = 0.0 , y = 1.05 , label = "Laplace " , srt = 0) 
text (x = -1.0, y = 1.05 , label = " Exponential " , srt = 0) 
text (x = 1.0 , y = 1.05 , label = "Exponential " , srt = 0) 
text (x = 0.0 , y = -0.1 , label = "Normal" , srt = 0) 
text (x = -0.6, y = 0.5 , label = " Hyperbolic , left skewed" , 
        srt = 302) 
text (x = 0.6 , y = 0.5 , label = " Hyperbolic , right skewed" , 
      srt = 57)


```